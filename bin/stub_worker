#!/usr/bin/perl -w
#################################
# A ZeroMQ worker for CorTeX    #
#  TeX-to-HTML5 conversions     #
#  via LaTeXML                  #
#################################

# Created and provided by Deyan Ginev
#   released in the Public Domain

### 
# Explanation: The goal here is to stay "safe" in the following aspects:
# - RAM allocation for CorTeX I/O - some jobs in arXiv are >1GB. Hence we stream both input and output into RAMdisk tempfiles.
# - RAM allocation for LaTeXML - Perl's garbage collector dangerously takes its time with certain structures, deallocating only at
#     process termination. To ensure deallocation, while also benefiting from the daemonization speedups, we do a Perl fork() for each latexml job.
# - Rogue infinite loops / busy malfunctions: arXiv has certain image files that send "convert" and "gs" for a loop, turning latexml unresponsive.
#     To counteract these we use: 
#     1) a separate process to observe the timeout (as even alarm() can't fire in some blocked cases!)
#     2) The 9 kill signal (only fire seemed to work)
#     3) The occasional worker restart, every 100 jobs or so.
# We pay a price here - fork() is an expensive op, however that is worth the price in order to ensure memory safety.
use File::Temp qw(tempfile);
use Archive::Zip qw(:CONSTANTS :ERROR_CODES);

# Obtain the path of this executable, for easy restart.
use FindBin;
my $RealBin_safe;
BEGIN {
  $FindBin::RealBin =~ /^([^\0]+)\z/; # Valid Unix path TODO: Windows, revisit regexp
  $RealBin_safe = $1;
  die 'Fatal:IO:tainted RealBin was tainted! Failing...'
   unless ($RealBin_safe && (-e $RealBin_safe.'/latexml_worker')); 
}


# Set up basic parameters for this CorTeX service
my $service_name = 'tex_to_html';
my $message_size = 100000;
my $work_counter = 0;
my $identity = join('',map { (q(a)..q(z))[rand(26)] } 1 .. 20);
my $timeout_limit = 600; # If worker isn't done in 2 s - timeout
# We also provide defaults for certain defensive environmental variables, if not yet set
#  in particular, for LaTeXML's ImageMagick conversion jobs.
#  pending review at: https://github.com/brucemiller/LaTeXML/pull/666
$ENV{MAGICK_DISK_LIMIT} = "2GiB" unless defined $ENV{MAGICK_DISK_LIMIT};
$ENV{MAGICK_MEMORY_LIMIT} = "512MiB" unless defined $ENV{MAGICK_MEMORY_LIMIT};
$ENV{MAGICK_MAP_LIMIT} = "1GiB" unless defined $ENV{MAGICK_MAP_LIMIT};
$ENV{MAGICK_TIME_LIMIT} = "300" unless defined $ENV{MAGICK_TIME_LIMIT};
# No excuses - use the RAM disk
$ENV{TMPDIR}='/dev/shm';

# Set up the cortex endpoints
my $cortex_ip = shift || '212.201.49.37';
my $cortex_ventilator_port = shift || '5555';
my $cortex_sink_port = shift || '5556';
my $ventilator_address = "tcp://$cortex_ip:$cortex_ventilator_port";
my $sink_address = "tcp://$cortex_ip:$cortex_sink_port";

print STDERR "-- Worker $identity started, waiting for jobs.\n";
while (1) {
  # restart_worker('job limit', $cortex_ip, $cortex_ventilator_port, $cortex_sink_port) if $work_counter > 100; # Respawn every 100 jobs, just to stay safe.
  
  $work_counter++;
  print STDERR "-- CorTeX task (worker job $work_counter) received, converting...\n";
  convert();
  print STDERR "-- Conversion complete, responding...\n";

}

sub convert {
  my ($taskid, $source, $destination) = @_;
  my $log_filepath = "cortex.log";
  # Set up conversion parameters for LaTeXML
  
  ### SPAWN a new LaTeXML process here, we are entering unsafe territory
  my $pid = fork();
  die if not defined $pid; # Error-handling
  ###
  # 1. CHILD
  if (not $pid) {
    setpgrp(0, 0);

    # External timer to prevent problems in system calls
    my $timer_pid = with_external_timer($timeout_limit);
    # CorTeX workhorses have lowest priority, to avoid overloading the machine
    setpriority(0, $$, 20);
    
    # Actual latexml conversion happens here.



    my $source = <<'EOS';
literal:\documentclass{article}
\usepackage{graphicx}
\begin{document}
Test: 
\def\foo{\foo}
\foo
\end{document}
EOS
    # Load as late as possible, to optimize runtime
    use LaTeXML;
    use LaTeXML::Common::Config;
    use Data::Dumper;
    # Set up conversion parameters for LaTeXML
    my $conversion_opts=LaTeXML::Common::Config->new(local=>1,whatsin=>'document',whatsout=>'document',
      destination=>'/tmp/stub.html',
      format=>'html5',mathparse=>'RecDescent',post=>1,math_formats=>['pmml','cmml'],
      preload=>['[ids]latexml.sty'],css=>['http://latexml.mathweb.org/css/external/LaTeXML.css'],
      defaultresources=>0, dographics=>1, inputencoding=>'iso-8859-1',timeout=>3,
      log=>$log_filepath);
    $conversion_opts->check;
    my $converter = LaTeXML->get_converter($conversion_opts);
    # Actual latexml conversion happens here.
    $converter->prepare_session($conversion_opts);
    my $response = $converter->convert($source);
    print STDERR Dumper($response);





    reset_external_timer($timer_pid); # Reset external timer 
    # This is a little silly -> the LaTeXML API does not (yet?) support direct local writing of Archives.
    # In other words, the final Archive is contained into $response - a potentially huge variable. 
    # In any case, let's write that variable into the needed destination:
    exit 0;
  }
  ###
  # 2. PARENT
  else {
    # Simply wait for the child to terminate:
    waitpid($pid, 0);
  }
}

### Utilities
# Restart support for keeping the worker operational over long inactivity periods
sub restart_worker {
  my ($reason,$cortex_ip, $cortex_ventilator_port, $cortex_sink_port) = @_;
  print STDERR "[".localtime()."] [$$] $reason reached, restarting\n";
  exec("$RealBin_safe/stub_worker",$cortex_ip, $cortex_ventilator_port, $cortex_sink_port)
    or die("Fatal:stub_worker:restart Worker $$ autoflush Failed!"); }

sub with_external_timer {
  my ($time) = @_;
  my $parent = $$;
  my $pid = fork();
  return $pid if $pid; # If parent finishes normally, it will kill $pid
  sleep $time; # Sleep for the timeout

  # Core timeout handler:
  # If we haven't been killed, there is a system call timeout => kill the parent
  print STDERR "[".localtime()."] [$$] Killing $parent via external timeout\n";
  # Record the failure:
  # $job->fail('Fatal:latexml_worker:timeout [$identity] Worker timed out after $time seconds.');

  # We really need KILL here, the "gs" infinite loop from LaTeXML can't be killed in any other way
  kill '-KILL', getpgrp($$);

  # And exit;
  exit 0; }

sub reset_external_timer {
  my ($pid) = @_;
  kill 9, $pid;
  return; }

1;